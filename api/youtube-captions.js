// Vercel Serverless Function - YouTube Caption/Transcript Fetcher
// Fetches video captions/transcripts using YouTube's Innertube API
// This is the most reliable method as of 2025

export default async function handler(req, res) {
  // Enable CORS for client-side requests
  res.setHeader('Access-Control-Allow-Credentials', true);
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS,POST');
  res.setHeader('Access-Control-Allow-Headers', 'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version');

  // Handle preflight OPTIONS request
  if (req.method === 'OPTIONS') {
    res.status(200).end();
    return;
  }

  // Only allow POST requests
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed. Use POST.' });
  }

  try {
    const { videoId } = req.body;

    if (!videoId) {
      return res.status(400).json({ error: 'Missing required field: videoId' });
    }

    // Step 1: Get video page to extract initial data
    const videoPageUrl = `https://www.youtube.com/watch?v=${videoId}`;
    const videoPageResponse = await fetch(videoPageUrl, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
      }
    });

    if (!videoPageResponse.ok) {
      return res.status(404).json({ error: 'Video not found or unavailable' });
    }

    const videoPageHtml = await videoPageResponse.text();

    // Step 2: Extract ytInitialPlayerResponse from page HTML
    const playerResponseMatch = videoPageHtml.match(/ytInitialPlayerResponse\s*=\s*({.+?})\s*;/);
    if (!playerResponseMatch) {
      return res.status(500).json({ error: 'Could not extract player data from video page' });
    }

    const playerResponse = JSON.parse(playerResponseMatch[1]);

    // Step 3: Extract caption tracks from player response
    const captionTracks = playerResponse?.captions?.playerCaptionsTracklistRenderer?.captionTracks;

    if (!captionTracks || captionTracks.length === 0) {
      return res.status(404).json({
        error: 'No captions available for this video',
        hasCaptions: false
      });
    }

    // Step 4: Select best caption track (prefer English, then auto-generated, then first available)
    let selectedTrack = captionTracks.find(track =>
      track.languageCode === 'en' && track.kind !== 'asr'
    ) || captionTracks.find(track =>
      track.languageCode === 'en'
    ) || captionTracks[0];

    // Step 5: Fetch the actual caption data
    const captionUrl = selectedTrack.baseUrl;
    const captionResponse = await fetch(captionUrl);

    if (!captionResponse.ok) {
      return res.status(500).json({ error: 'Failed to fetch caption data' });
    }

    const captionXml = await captionResponse.text();

    // Step 6: Parse XML captions into structured format
    const captions = parseCaptionXml(captionXml);

    return res.status(200).json({
      success: true,
      hasCaptions: true,
      language: selectedTrack.languageCode,
      isAutoGenerated: selectedTrack.kind === 'asr',
      captions: captions,
      trackInfo: {
        language: selectedTrack.name?.simpleText || selectedTrack.languageCode,
        isAutoGenerated: selectedTrack.kind === 'asr'
      }
    });

  } catch (error) {
    console.error('Caption extraction error:', error);
    return res.status(500).json({
      error: 'Internal server error',
      message: error.message
    });
  }
}

// Helper function to parse YouTube caption XML
function parseCaptionXml(xml) {
  const captions = [];

  // Extract text nodes with start time and duration
  const textRegex = /<text start="([^"]+)" dur="([^"]+)"[^>]*>([^<]*)<\/text>/g;
  let match;

  while ((match = textRegex.exec(xml)) !== null) {
    const startSeconds = parseFloat(match[1]);
    const durationSeconds = parseFloat(match[2]);
    const text = decodeHtmlEntities(match[3]);

    captions.push({
      start: startSeconds,
      duration: durationSeconds,
      text: text.trim()
    });
  }

  return captions;
}

// Helper function to decode HTML entities in caption text
function decodeHtmlEntities(text) {
  const entities = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'",
    '&nbsp;': ' '
  };

  return text.replace(/&[^;]+;/g, entity => entities[entity] || entity);
}
